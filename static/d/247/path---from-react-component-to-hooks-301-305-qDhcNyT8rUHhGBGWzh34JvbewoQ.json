{"data":{"site":{"siteMetadata":{"title":"pjb0811.github.io","author":"Jeongbin Park"}},"markdownRemark":{"id":"1840a734-4b61-5aab-b7a0-67c428a889a5","excerpt":"최근, React 는  16.7 출시 계획을 발표했다.  이번 발표는 Stateless 한 기능의 컴포넌트(SFC)를 중심으로 한 새로운 접근 방식을 홍보하기 때문에 상당히 큰 의미를 지닌다. 그렇게 하기 위해, 이 새로운 버전의 library…","html":"<p>최근, React 는 <strong><a href=\"https://reactjs.org/docs/hooks-intro.html\">16.7 출시 계획을 발표했다.</a></strong> 이번 발표는 Stateless 한 기능의 컴포넌트(SFC)를 중심으로 한 새로운 접근 방식을 홍보하기 때문에 상당히 큰 의미를 지닌다.</p>\n<p>그렇게 하기 위해, 이 새로운 버전의 library 는 개발자들이 상태를 저장하고, side effect 를 트리거하고 처리할 수 있는 도구인 “hooks”라고 불리는 것을 제공한다.</p>\n<p>이러한 접근 방식이 확실히 (내 생각에) 개선되고 대응에 있어 큰 진전이지만, 개발자들이 처음에는 이해하기 어려울 수 있기 때문에 그것을 채택하는 것은 상당히 어려울 수 있다. 바라건대, 이 기사가 끝날 때까지 여러분은 hooks 와 그것들을 이용할 수 있는 방법에 대해 더 잘 이해할 수 있을 것입니다.</p>\n<h2>hooks 작동 방식</h2>\n<p>작동 방식을 이해하기 위해 알아야 할 가장 큰 것은 hooks 가 구성 요소를 장착할 때 React 에 의해 <strong>순서</strong>대로 나열되고 업데이트 시 <strong>동일한 순서</strong>로 처리된다는 점입니다. 순서 부분은 여기서 중요한 부분이며, 그것이 무엇을 의미할까요?</p>\n<p>사용자 ID 를 가져와서 프로필을 가져와서 이름을 사용하여 해당 사용자에게 인사하는 간단한 구성 요소가 있다고 가정해 보겠습니다.</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/69c7e68b61938651fa43f60087d27aab/c3b2a/simple-user-greeting-component.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 65.8%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAABc0lEQVQoz42SCW6DMBBFOUubpmFJICzGxivGYJpGaqTe/y79iROatqpa6YNGZt7MZzxRpqZCjalwZT8XwpbabaiOuU4Zfypp0GrfBj0WBO/lPKqoJ/zA5Ez5ZDqbcZ+LqWjlumIh47nutp0J2nEbE7HwUcE8EzNnmrcyp0OuThRGavZ4yUDepuGVmRo713Ym7oASn3AMoH9rx6k0GqqsrYYDsnNhQwYsJK28SKVUJUSucH7hIzy5eh20Z9LV/ViasdA+bSUaLjCcB4UYnyDEZ3grXsjw3hr/XNKHnFyncvOGvFwMhRz2yuXniY6Id6JHFcBtJl6oOTHtE8Lvh7kMDMyO91DGdIgzZtZVF6F7xh2c12ba1N3qK7nAN+YKY2znzjHVzB8b6xOqzm1vN3Qv/EjQctXBYBQz04zHvZnXVGOeqPcT/k2A+9q9bsUQUxM34tsO/Q2nkBhj7rBA2NOE6vU/4UQ4AJl0e+0KNWwIFvO/zj8A24mflYMWat4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"simple user-greeting component\"\n        title=\"\"\n        src=\"/static/69c7e68b61938651fa43f60087d27aab/fb8a0/simple-user-greeting-component.png\"\n        srcset=\"/static/69c7e68b61938651fa43f60087d27aab/1a291/simple-user-greeting-component.png 148w,\n/static/69c7e68b61938651fa43f60087d27aab/2bc4a/simple-user-greeting-component.png 295w,\n/static/69c7e68b61938651fa43f60087d27aab/fb8a0/simple-user-greeting-component.png 590w,\n/static/69c7e68b61938651fa43f60087d27aab/526de/simple-user-greeting-component.png 885w,\n/static/69c7e68b61938651fa43f60087d27aab/c3b2a/simple-user-greeting-component.png 1000w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>React 는 이 구성 요소를 처음으로 렌더링할 때(즉, 구성 요소의 mounting 이 발생할 때) React hook 의 각 호출을 연속적으로 등록합니다. 즉, 다음과 같은 기능을 합니다.</p>\n<ul>\n<li>“초기 값이 <code class=\"language-text\">true</code> 인 새로운 상태를 만들 것입니다.”</li>\n<li>“초기 값이 <code class=\"language-text\">null</code> 인 새로운 상태를 만들 것입니다.</li>\n<li>“초기 값이 <code class=\"language-text\">null</code> 인 새로운 상태를 만들 것입니다(이전 값과 다름).</li>\n<li>“effect 를 만들고 즉시 그것을 호출할 것입니다.” (프로세스 <code class=\"language-text\">userId</code> 가 동일하게 유지되는 한 이 effect 는 다시 생성되지 않습니다.)</li>\n</ul>\n<p>이제 <code class=\"language-text\">fetch</code> function 이 일부 데이터를 반환하고 <code class=\"language-text\">setLoading</code> 및 <code class=\"language-text\">setUser</code> function 을 호출한다고 가정하겠습니다. 이러한 function 은 우리가 만든 첫 번째 및 두 번째 상태를 업데이트하고 구성 요소의 re-rendering 을 트리거합니다. 즉, 전체 코드를 다시 살펴본 후 React 는 다른 작업을 수행합니다.</p>\n<ul>\n<li>“이 구성 요소에 대한 첫 번째 상태가 있으며 그 값은 <code class=\"language-text\">false</code> 입니다. 새 값을 만드는 대신 값을 돌려 줄 것입니다.”</li>\n<li>“이 구성 요소에 대한 두 번째 상태가 있으며 그 값은 [API 가 보낸 모든 것]이며, 새 값을 만드는 대신 되돌려줍니다.”</li>\n<li>“이 구성 요소에 대한 세 번째 상태가 있으며 그 값은 여전히 <code class=\"language-text\">false</code> 입니다. 새 값을 만드는 대신 다시 값을 주겠습니다.”</li>\n<li>“이미 이 effect 를 등록했는데 props <code class=\"language-text\">userId</code> 가 변경되지 않았으므로 다시 호출할 필요가 없습니다.”</li>\n</ul>\n<p>React 는 hooks 에 대한 모든 호출을 등록함으로써 “state”를 내부적으로 저장하고 필요한 정보를 제공할 수 있습니다. 우리는 <strong>React hooks 의 두 가지 규칙을 존중</strong>하기 때문에 그렇게 할 수 있습니다.</p>\n<ul>\n<li>\n<p>React 구성 요소 외부에 있는 hooks 를 호출할 수 없습니다(분명히 렌더링 단계에서 React 에 의해 처리되어야 하기 때문에 render function 에 넣어야 하며, 이 경우 SFC 에 해당합니다).</p>\n</li>\n<li>\n<p>hooks 의 순서와 목록은 변경할 수 없습니다. 구성 요소의 두 번째 <code class=\"language-text\">useState</code>를 제거한다고 가정해 보겠습니다. React 는 첫번째 것을 보고, 그것을 위해 저장한 상태를 돌려주고, 다른 것을 보지만 세 번째는 보지 않습니다. 어느 것이 사라졌는지 알 수 없고 실수를 저지를 것이다.</p>\n</li>\n</ul>\n<h2>lifecycle 방식에서 hooks 로 마이그레이션</h2>\n<h3>componentDidMount 에서 useMount 까지</h3>\n<p><code class=\"language-text\">componentDidMount</code> 메서드는 일반적으로 구성 요소가 마운트될 때 한 번 side effect 가 트리거되는 방법입니다.</p>\n<p>동등한 hook 는 SFC 가 처음으로 호출될 때 side effect 가 발생하며 이후 호출을 중단한다. 이를 위해 사용할 수 있는 hook 는 <code class=\"language-text\">useEffect</code> 라고 합니다. 기본적으로 구성 요소를 마운트 및 업데이트할 때마다 호출됩니다. 설명서를 자세히 살펴보면 일련의 값을 두 번째 인수로 전달하여 “memoized”할 수 있음을 알 수 있습니다. 또한 빈 배열을 통과하는 것은 React 에게 한 번 더 요청한 후 <strong>다시는 요청하지 않습니다.</strong> 빈 배열은 “이 기능이 변경될 때 오래된 결과를 가져올 값은 없습니다.”라고 말하는 것과 같습니다. 따라서 <code class=\"language-text\">componentDidUpdate</code> 구현은 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useEffect <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">useMount</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 기능을 <code class=\"language-text\">void</code>로 호출함으로써, 우리는 hook 이 <code class=\"language-text\">undefined</code>를 반환하는것을 확인합니다(<code class=\"language-text\">componentWillUnmount</code>를 모방하려고 할 때 왜 중요한지 알 수 있습니다. 빈 배열을 전달하기 때문에, React 는 효과를 한 번 적용하고 메모 프로세스에서 값이 관찰되지 않으므로 결코 업데이트하지 않습니다). 따라서 구성 요소가 mount 될 때 호출됩니다.</p>\n<h2>componentWillUnmount 에서 useUnmount 로</h2>\n<p><code class=\"language-text\">componentWillUnmount</code> 메소드는 side effect 를 유발하는데도 사용되지만 이번에는 컴포넌트가 마운트 해제 될 때 사용됩니다. 예를 들어 이벤트 리스너를 만들고 삭제하는 것과 같이 <code class=\"language-text\">componentDidMount</code> 와 함께 사용하는 경우는 일반적이지 않습니다.</p>\n<p>이전 장에서 보았 듯이 빈 값 배열을 전달하여 모든 렌더링에서 후크가 발생하지 않도록 할 수 있습니다. 그렇게함으로써 우리는 한번 마운트 한 다음 한번도 호출하지 말라고합니다. 하지만 마운트 시간에 한 번 요청하지 않고 마운트 해제 시간에 요청을 하면 어떨까요? <code class=\"language-text\">useEffect</code>의 문서에는 <code class=\"language-text\">useEffect</code> hook 이라는 함수에 의해 반환된 모든 기능이 구성 요소가 마운트 해제될 때 호출됩니다.</p>","frontmatter":{"title":"React.Component에서 hooks로","date":"2018.10.29","tags":["javascript","react"],"translation":{"title":"From React.Component to hooks","link":"https://medium.com/@dispix/from-react-component-to-hooks-b50241334365"},"mainImage":{"childImageSharp":{"sizes":{"aspectRatio":2,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHJqrWSAP/EABgQAQADAQAAAAAAAAAAAAAAAAEAAhAS/9oACAEBAAEFApcyqk6c/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEQITH/2gAIAQEABj8CMUxnXP/EABsQAQACAgMAAAAAAAAAAAAAAAEAERAxUXHh/9oACAEBAAE/IQXRAouOcWlh0w9bH//aAAwDAQACAAMAAAAQ0B//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPxCH/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAIDAQEAAAAAAAAAAAAAAQARITFBEHH/2gAIAQEAAT8QdyPyDWkOPKsG7ELg1os8cds//9k=","sizes":"(max-width: 1200px) 100vw, 1200px","src":"/static/3c472ac0eb82147f53749d4a817df1e8/9fbf0/react-hooks.jpg","srcSet":"/static/3c472ac0eb82147f53749d4a817df1e8/b95c3/react-hooks.jpg 300w,\n/static/3c472ac0eb82147f53749d4a817df1e8/9ff9f/react-hooks.jpg 600w,\n/static/3c472ac0eb82147f53749d4a817df1e8/9fbf0/react-hooks.jpg 1200w,\n/static/3c472ac0eb82147f53749d4a817df1e8/54c35/react-hooks.jpg 1500w"}}}}}},"pageContext":{"slug":"/from-react-component-to-hooks/","previous":{"id":"ada8cae6-52a1-57de-87b7-56e58f8eb924","excerpt":"test 13123","frontmatter":{"title":"페이징 작업용 테스트 긴 제목으로 작성 하하하하하 123 qwerasdf","date":"2018.10.24","tags":["html","javascript"],"translation":null,"mainImage":{"childImageSharp":{"sizes":{"aspectRatio":2.064516129032258,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAv/EABYBAQEBAAAAAAAAAAAAAAAAAAIBA//aAAwDAQACEAMQAAABczDclAWBv//EABoQAAICAwAAAAAAAAAAAAAAAAABAhASEzL/2gAIAQEAAQUCSE8jVUOz/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAAhD/2gAIAQIBAT8BM//EABkQAAIDAQAAAAAAAAAAAAAAAAAxAQIRIP/aAAgBAQAGPwImmIfH/8QAGxAAAwACAwAAAAAAAAAAAAAAAAERECFBYXH/2gAIAQEAAT8huVTtpW4PsFwap68f/9oADAMBAAIAAwAAABC/D//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/EKf/xAAWEQADAAAAAAAAAAAAAAAAAAABECH/2gAIAQIBAT8QoL//xAAdEAEBAAIBBQAAAAAAAAAAAAABEQAhMUFRcYGR/9oACAEBAAE/EGRJXRcWxDCC9j1u4C1+uPed0aWk648vnP/Z","sizes":"(max-width: 800px) 100vw, 800px","src":"/static/333579e8f0baa3c823114f65c86b91d5/381d6/dog.jpg","srcSet":"/static/333579e8f0baa3c823114f65c86b91d5/62f05/dog.jpg 200w,\n/static/333579e8f0baa3c823114f65c86b91d5/dc2b4/dog.jpg 400w,\n/static/333579e8f0baa3c823114f65c86b91d5/381d6/dog.jpg 800w,\n/static/333579e8f0baa3c823114f65c86b91d5/e5d70/dog.jpg 1200w,\n/static/333579e8f0baa3c823114f65c86b91d5/0e8f1/dog.jpg 1280w"}}}},"fields":{"slug":"/test-page-2/"}},"next":null}}