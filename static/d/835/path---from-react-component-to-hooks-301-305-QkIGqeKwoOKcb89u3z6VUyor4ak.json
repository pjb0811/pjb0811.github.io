{"data":{"site":{"siteMetadata":{"title":"pjb0811.github.io","author":"Jeongbin Park"}},"markdownRemark":{"id":"1840a734-4b61-5aab-b7a0-67c428a889a5","excerpt":"아주 최근에, React 는 다가오는  16.7 버전에 대한 계획을 발표했습니다. . 이번 발표는 Stateless 한 기능의 컴포넌트(SFC…","html":"<p>아주 최근에, React 는 다가오는 <strong><a href=\"https://reactjs.org/docs/hooks-intro.html\">16.7 버전에 대한 계획을 발표했습니다.</a></strong>. 이번 발표는 Stateless 한 기능의 컴포넌트(SFC)를 중심으로 새로운 접근 방식을 추진하기 때문에 상당히 방대합니다.</p>\n<p>그것을 사용하기 위해 새로운 버전의 라이브러는는 “후크 (hooks)“라고 부르는 것을 제공합니다. 이 도구는 개발자가 상태를 저장하고, side effect 를 처리하며, 훨씬 더 많은 SFC 내부를 처리 할 수있게 해주는 도구입니다.</p>\n<p>이 접근 방식이 분명히 (필자의 의견으로는) React 에 대한 개선과 큰 진전이 있지만, 처음에는 후크를 이해하기 어려울 수 있기 때문에 개발자가 그것을 채택하는 것은 상당히 어려울 수 있습니다. 다행히도이 기사의 끝 부분에서는 후크에 대해 더 잘 이해하고 이를 활용할 수있는 방법을 모색하게 될 것입니다.</p>\n<h2>hooks 작동 방식</h2>\n<p>그들이 작동하는 방법을 이해하는 가장 큰 방법은 다음과 같습니다. 후크는 컴포넌트를 마운트 할 때 React 가 <strong>순서</strong>대로 나열한 다음, 컴포넌트를 업데이트 할 때 <strong>동일한 순서</strong>로 처리됩니다. 순서 부분은 여기서 중요한 부분이며, 그것이 무엇을 의미할까요?</p>\n<p>사용자 ID 를 가져와서 프로필을 가져와서 이름을 사용하여 해당 사용자에게 인사하는 간단한 컴포넌트가 있다고 가정해 보겠습니다.</p>\n<figure>\n  \n  <a class=\"gatsby-resp-image-link\" href=\"/static/69c7e68b61938651fa43f60087d27aab/c3b2a/simple-user-greeting-component.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n  \n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 65.8%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAABc0lEQVQoz42SCW6DMBBFOUubpmFJICzGxivGYJpGaqTe/y79iROatqpa6YNGZt7MZzxRpqZCjalwZT8XwpbabaiOuU4Zfypp0GrfBj0WBO/lPKqoJ/zA5Ez5ZDqbcZ+LqWjlumIh47nutp0J2nEbE7HwUcE8EzNnmrcyp0OuThRGavZ4yUDepuGVmRo713Ym7oASn3AMoH9rx6k0GqqsrYYDsnNhQwYsJK28SKVUJUSucH7hIzy5eh20Z9LV/ViasdA+bSUaLjCcB4UYnyDEZ3grXsjw3hr/XNKHnFyncvOGvFwMhRz2yuXniY6Id6JHFcBtJl6oOTHtE8Lvh7kMDMyO91DGdIgzZtZVF6F7xh2c12ba1N3qK7nAN+YKY2znzjHVzB8b6xOqzm1vN3Qv/EjQctXBYBQz04zHvZnXVGOeqPcT/k2A+9q9bsUQUxM34tsO/Q2nkBhj7rBA2NOE6vU/4UQ4AJl0e+0KNWwIFvO/zj8A24mflYMWat4AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;\">\n      <img class=\"gatsby-resp-image-image\" style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\" alt=\"my alt text\" title=\"\" src=\"/static/69c7e68b61938651fa43f60087d27aab/fb8a0/simple-user-greeting-component.png\" srcset=\"/static/69c7e68b61938651fa43f60087d27aab/1a291/simple-user-greeting-component.png 148w,\n/static/69c7e68b61938651fa43f60087d27aab/2bc4a/simple-user-greeting-component.png 295w,\n/static/69c7e68b61938651fa43f60087d27aab/fb8a0/simple-user-greeting-component.png 590w,\n/static/69c7e68b61938651fa43f60087d27aab/526de/simple-user-greeting-component.png 885w,\n/static/69c7e68b61938651fa43f60087d27aab/c3b2a/simple-user-greeting-component.png 1000w\" sizes=\"(max-width: 590px) 100vw, 590px\">\n    </span>\n  </span>\n  \n  </a>\n    \n  <figcaption>&#xAC04;&#xB2E8;&#xD55C; &#xC0AC;&#xC6A9;&#xC790; &#xC778;&#xC0AC;&#xB9D0; &#xCEF4;&#xD3EC;&#xB10C;&#xD2B8;</figcaption>\n</figure>\n<p>React 는 이 컴포넌트를 처음으로 렌더링할 때(즉, 컴포넌트가 <em>마운트</em> 될 때) React hook 의 각 호출을 연속적으로 등록합니다. 즉, 다음과 같은 기능을 합니다.</p>\n<ul>\n<li><em>“초기 값이 <code class=\"language-text\">true</code> 인 새로운 상태를 만들 것입니다.”</em></li>\n<li><em>“초기 값이 <code class=\"language-text\">null</code> 인 새로운 상태를 만들 것입니다.”</em></li>\n<li><em>“초기 값이 <code class=\"language-text\">null</code> 인 새로운 상태를 만들 것입니다”</em>(이전 값과 다름).</li>\n<li><em>“effect 를 만들고 즉시 호출할 것입니다.”</em> (프로세스 <code class=\"language-text\">userId</code> 가 동일하게 유지되는 한 이 effect 는 다시 생성되지 않습니다.)</li>\n</ul>\n<p>이제 <code class=\"language-text\">fetch</code> function 이 일부 데이터를 반환하고 <code class=\"language-text\">setLoading</code> 및 <code class=\"language-text\">setUser</code> function 을 호출한다고 가정하겠습니다. 이러한 function 은 우리가 만든 첫 번째 및 두 번째 상태를 업데이트하고 컴포넌트의 re-rendering 을 트리거합니다. 즉, 전체 코드를 다시 살펴본 후 React 는 다른 작업을 수행합니다.</p>\n<ul>\n<li><em>“이 컴포넌트에 대한 첫 번째 상태가 있으며 그 값은 <code class=\"language-text\">false</code> 입니다. 새 값을 만드는 대신 값을 돌려 줄 것입니다.”</em></li>\n<li><em>“이 컴포넌트에 대한 두 번째 상태가 있으며 그 값은 [API 가 보낸 모든 것]이며, 새 값을 만드는 대신 되돌려줍니다.”</em></li>\n<li><em>“이 컴포넌트에 대한 세 번째 상태가 있으며 그 값은 여전히 <code class=\"language-text\">false</code> 입니다. 새 값을 만드는 대신 다시 값을 주겠습니다.”</em></li>\n<li><em>“이미 이 effect 를 등록했는데 props <code class=\"language-text\">userId</code> 가 변경되지 않았으므로 다시 호출할 필요가 없습니다.”</em></li>\n</ul>\n<p>React 는 후크에 대한 모든 호출을 등록함으로써 “상태”를 내부적으로 저장하고 필요한 정보를 제공할 수 있습니다. 우리는 <strong>React hooks 의 두 가지 규칙을 존중</strong>하기 때문에 그렇게 할 수 있습니다.</p>\n<ul>\n<li>\n<p>우리는 React 컴포넌트 외부에서 후크를 호출 할 수 없습니다(렌더링 단계 중 React 가 처리해야하므로 렌더링 함수 또는 이 경우에는 SFC 에 넣어야 함).</p>\n</li>\n<li>\n<p><code class=\"language-text\">후크의 순서와 목록을 변경할 수는 없습니다</code>. 컴포넌트의 두 번째 <code class=\"language-text\">useState</code>를 제거한다고 가정해 보겠습니다. React 는 첫 번째 것을보고, 그걸 저장 한 상태로 되돌리고, 세 번째가 아닌 다른 것을 봅니다. 어느 것이 사라 졌는지 알 수 없으며 오류가 발생합니다.</p>\n</li>\n</ul>\n<h2>lifecycle 방식에서 hooks 로 마이그레이션</h2>\n<h3>componentDidMount 에서 useMount 까지</h3>\n<p><code class=\"language-text\">componentDidMount</code> 메서드는 일반적으로 컴포넌트가 마운트될 때 side effect 를 유발하는 방법입니다.</p>\n<p>해당 후크는 SFC 가 처음으로 호출 될 때 side effect 을 유발하고 그 후에 호출되는 것을 중지하는 무언가 일 것입니다. 이를 위해 사용할 수 있는 hook 는 <code class=\"language-text\">useEffect</code> 라고 합니다. 기본적으로 컴포넌트를 마운트 및 업데이트할 때마다 호출됩니다. 문서를 자세히 살펴보면 배열을 두 번째 인수로 전달하여 “메모가 가능”하다는 것을 알 수 있습니다. 또한 빈 배열을 전달하면 React 에게 <strong>한 번만 호출하면됩니다</strong>. 빈 배열은 “이 함수 결과가 변경 될 때 구형이 될 값이 없다”는 것과 같습니다. 따라서 <code class=\"language-text\">componentDidUpdate</code> 구현은 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useEffect <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">useMount</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>function 을 <code class=\"language-text\">void</code>로 호출함으로써, 우리는 hook 이 <code class=\"language-text\">undefined</code>를 반환하는것을 확인합니다(<code class=\"language-text\">componentWillUnmount</code>를 모방하려고 할 때 왜 중요한지 알 수 있습니다. 빈 배열을 전달하기 때문에, React 는 효과를 한 번 적용하고 메모 프로세스에서 값이 관찰되지 않으므로 결코 업데이트하지 않습니다). 따라서 컴포넌트가 mount 될 때 호출됩니다.</p>\n<h3>componentWillUnmount 에서 useUnmount 로</h3>\n<p><code class=\"language-text\">componentWillUnmount</code> 메소드는 side effect 를 유발하는데도 사용되지만 이번에는 컴포넌트가 마운트 해제 될 때 사용됩니다. 예를 들어 이벤트 리스너를 만들고 삭제하는 것과 같이 <code class=\"language-text\">componentDidMount</code> 와 함께 사용하는 경우는 일반적이지 않습니다.</p>\n<p>이전 장에서 보았 듯이 빈 값 배열을 전달하여 모든 렌더링에서 후크가 발생하지 않도록 할 수 있습니다. 그렇게 함으로써 우리는 한번 마운트 한 다음 한번도 호출하지 말라고 합니다. 하지만 마운트 시 요청하지 않고 마운트 해제 시 요청을 하면 어떨까요? <code class=\"language-text\">useEffect</code>의 문서에는 <code class=\"language-text\">useEffect</code> 후크에 의해 호출 된 함수에 의해 반환된 모든 기능이 컴포넌트가 마운트 해제될 때 호출됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useEffect <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">useUnmount</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> fn<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>arrow function 을 호출하면 아무것도 하지 않고 React 가 컴포넌트를 마운트 해제 할 때 호출할 함수에 대한 참조를 반환합니다. 다시 한번, 빈 배열을 전달하면 모든 렌더링에 대해 함수를 반복적으로 호출하지 않게 됩니다.(어쨌든 아무것도 하지 않기 때문에 자원 낭비가 될 수 있습니다.)</p>\n<h3>componentDidUpdate 에서 useUpdate 까지</h3>\n<p>마지막으로 우리는 <code class=\"language-text\">componentDidUpdate</code> 의 동작을 모방하고 싶습니다. 이 동작은 <strong>초기 렌더링을 제외한</strong> 모든 렌더링에서 호출됩니다.</p>\n<p>이전 예제에서 <code class=\"language-text\">useEffect</code>는 특정 조건에서 통과하는 함수를 호출하도록 지시하는 두 번째 매개 변수를 사용하는 것을 보았습니다. 이 인수를 전달하지 않음으로써 우리는 React 에게 <em>“이 효과가 렌더에서 호출되는 것을 막아서는 안됩니다”</em> 라고 전합니다. 그것은 첫 번째 것을 포함하기 때문에, 우리는 특별히 이것을 처리 할 필요가 있습니다. 그러나 나머지 시간에는 React 가 조건에 관계없이 효과를 나타낼 것입니다. 초기 렌더링의 경우, 초기 렌더링 또는 그 이후의 렌더링인지 여부를 알려주는 값 (boolean 값)을 선언해야합니다. 이 값은 업데이트 할 때 트리거 및 새로운 렌더링을 해서는 안되며 <code class=\"language-text\">useUpdate</code> 함수를 통해 액세스 할 수 있어야합니다.</p>\n<p>이것은 <code class=\"language-text\">useRef</code> 메소드로 수행 할 수 있는 작업입니다. <code class=\"language-text\">useRef</code>는 우리 컴포넌트의 재렌더링을 트리거하지 않는 <code class=\"language-text\">useState</code>로 생각하십시오. 그래서 우리가 해야 할 일은 우리의 <code class=\"language-text\">useMount</code> 함수를 약간 수정하는 것입니다 :</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useRef<span class=\"token punctuation\">,</span> useEffect <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">useUpdate</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> mounting <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mounting<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      mounting<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 코드에서 우리는 :</p>\n<ul>\n<li><code class=\"language-text\">useRef</code> 후크를 사용하여 <code class=\"language-text\">참조</code>를 만듭니다. 이것은 우리가 우리 후크의 연속 호출 사이에서 액세스 할 수 있는 어딘가에 boolean 을 저장할 수 있게 해줍니다.</li>\n<li><strong>항상 effect 를 호출하십시오</strong>. 이것은 두 가지 hooks 규칙 중 하나입니다. 이 기사의 앞 부분에서 설명한 것처럼 React 는 후크 <strong>순서</strong>를 사용하여 코드에 저장하고 전달할 값을 결정합니다.</li>\n<li><code class=\"language-text\">useEffect</code> hook 의 arrow function 에서 이전에 저장된 값을 읽습니다. 그것이 true 라면, 우리는 여전히 초기 렌더링에 있습니다. 그래서 우리는 단지 false 로 설정했기 때문에 다음에 같은 코드 행에 도착하면 우리의 값은 우리가 더 이상 초기 렌더링에 있지 않다는 것을 정확하게 나타내며 우리는 함수를 호출합니다.</li>\n<li>우리는 <code class=\"language-text\">useEffect</code>에 대한 두 번째 인수를 undefined 로 설정합니다. 즉, 후크를 트리거하지 못하도록 하는 것이 아무것도 없음을 React 에 지정합니다.</li>\n</ul>\n<h3>shouldComponentUpdate 에서 memo 및 useMemo 로</h3>\n<p><code class=\"language-text\">shouldComponentUpdate</code>는 이전 내용과 똑같지는 않습니다. React 16.7 을 사용하면 다음 중 하나를 수행 할 수 있습니다.</p>\n<ul>\n<li>React.PureComponent 처럼 <code class=\"language-text\">memo</code>를 사용하여 props 와 관련하여 컴포넌트를 memoize 하십시오.</li>\n<li><code class=\"language-text\">useMemo</code>를 사용하여 컴포넌트의 자식을 memoize 합니다.</li>\n</ul>\n<p>자세한 내용은 <a href=\"https://reactjs.org/docs/hooks-faq.html#how-to-memoize-calculations\">FAQ</a>를 참조하십시오.</p>\n<h3>getDerivedStateFromProps 에서 …까지 렌더링</h3>\n<p>상태가 이제 렌더링 함수에 직접 위치하기 때문에 (컴포넌트가 렌더링 함수이므로) 상태를 업데이트하기 위해 후크가 필요하지 않습니다. <a href=\"https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops\">FAQ</a> 는 그것에 대해 충분하게 말합니다.</p>\n<h3>componentDidCatch 에서 아무것도 …하지 않을때</h3>\n<p>안타깝게도 이 시점에서 <code class=\"language-text\">componentDidCatch</code> 에 해당하는 요소가 없으므로 유일한 해결책은 고전적인 <code class=\"language-text\">React.Component</code> 를 만드는 것입니다.</p>\n<h3>useEffect 대신에 useLayoutEffect 사용하기</h3>\n<p><a href=\"https://reactjs.org/docs/hooks-reference.html#uselayouteffect\">React 문서</a>가 명시했듯이 구현 시 <code class=\"language-text\">useLayoutEffect</code> 후크를 사용하면 사용자 정의 후크가 React 컴포넌트 라이프 사이클 메소드의 초기 동작에 가깝게 됩니다. 그러나 시각적 업데이트를 차단하지 않으려면 <code class=\"language-text\">useEffect</code> 후크를 사용하는 것이 좋습니다.</p>\n<p>그러므로, 당신이 하나 또는 다른 것을 사용해야 하는지를 결정하는 것이 당신을 위한 것입니다. 내 접근 방식은 <code class=\"language-text\">useEffect</code> 후크를 사용하고 첫 번째가 예상대로 동작하지 않을 때 fallback 으로 <code class=\"language-text\">useLayoutEffect</code> 후크를 사용하는 것입니다. 예를 들어 <code class=\"language-text\">fetch</code> 네트워크 호출과 같은 대부분의 side effect 에 대해서는 전자가 문제를 일으키지 않아야합니다.</p>\n<h3>후크 예제</h3>\n<p>이 기본적인 tic tac toe 게임은 React 16.7 을 사용하여 만들어졌으며 후크를 최대한 활용합니다. 주저하지 말고 탐색하거나 복제하십시오!</p>\n<iframe scrolling=\"no\" frameborder=\"0\" id=\"player\" src=\"https://codesandbox.io/embed/github/dispix/react-hooks-example?referrer=https%3A%2F%2Fmedium.com%2Fmedia%2F1c8ebd81c7f523fe764ad3e7ecd63f6c%3FpostId%3Db50241334365\" allowfullscreen=\"true\"></iframe>","frontmatter":{"title":"React.Component에서 hooks로","date":"2018.10.29","tags":["javascript","react"],"translation":{"title":"From React.Component to hooks","link":"https://medium.com/@dispix/from-react-component-to-hooks-b50241334365"},"mainImage":{"childImageSharp":{"sizes":{"aspectRatio":2,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHJqrWSAP/EABgQAQADAQAAAAAAAAAAAAAAAAEAAhAS/9oACAEBAAEFApcyqk6c/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEQITH/2gAIAQEABj8CMUxnXP/EABsQAQACAgMAAAAAAAAAAAAAAAEAERAxUXHh/9oACAEBAAE/IQXRAouOcWlh0w9bH//aAAwDAQACAAMAAAAQ0B//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPxCH/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAIDAQEAAAAAAAAAAAAAAQARITFBEHH/2gAIAQEAAT8QdyPyDWkOPKsG7ELg1os8cds//9k=","sizes":"(max-width: 1200px) 100vw, 1200px","src":"/static/3c472ac0eb82147f53749d4a817df1e8/9fbf0/react-hooks.jpg","srcSet":"/static/3c472ac0eb82147f53749d4a817df1e8/b95c3/react-hooks.jpg 300w,\n/static/3c472ac0eb82147f53749d4a817df1e8/9ff9f/react-hooks.jpg 600w,\n/static/3c472ac0eb82147f53749d4a817df1e8/9fbf0/react-hooks.jpg 1200w,\n/static/3c472ac0eb82147f53749d4a817df1e8/54c35/react-hooks.jpg 1500w"}}}}}},"pageContext":{"slug":"/from-react-component-to-hooks/","previous":{"id":"ada8cae6-52a1-57de-87b7-56e58f8eb924","excerpt":"test 13123","frontmatter":{"title":"페이징 작업용 테스트 긴 제목으로 작성 하하하하하 123 qwerasdf","date":"2018.10.24","tags":["html","javascript"],"translation":null,"mainImage":{"childImageSharp":{"sizes":{"aspectRatio":2.064516129032258,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAv/EABYBAQEBAAAAAAAAAAAAAAAAAAIBA//aAAwDAQACEAMQAAABczDclAWBv//EABoQAAICAwAAAAAAAAAAAAAAAAABAhASEzL/2gAIAQEAAQUCSE8jVUOz/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAAhD/2gAIAQIBAT8BM//EABkQAAIDAQAAAAAAAAAAAAAAAAAxAQIRIP/aAAgBAQAGPwImmIfH/8QAGxAAAwACAwAAAAAAAAAAAAAAAAERECFBYXH/2gAIAQEAAT8huVTtpW4PsFwap68f/9oADAMBAAIAAwAAABC/D//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/EKf/xAAWEQADAAAAAAAAAAAAAAAAAAABECH/2gAIAQIBAT8QoL//xAAdEAEBAAIBBQAAAAAAAAAAAAABEQAhMUFRcYGR/9oACAEBAAE/EGRJXRcWxDCC9j1u4C1+uPed0aWk648vnP/Z","sizes":"(max-width: 800px) 100vw, 800px","src":"/static/333579e8f0baa3c823114f65c86b91d5/381d6/dog.jpg","srcSet":"/static/333579e8f0baa3c823114f65c86b91d5/62f05/dog.jpg 200w,\n/static/333579e8f0baa3c823114f65c86b91d5/dc2b4/dog.jpg 400w,\n/static/333579e8f0baa3c823114f65c86b91d5/381d6/dog.jpg 800w,\n/static/333579e8f0baa3c823114f65c86b91d5/e5d70/dog.jpg 1200w,\n/static/333579e8f0baa3c823114f65c86b91d5/0e8f1/dog.jpg 1280w"}}}},"fields":{"slug":"/test-page-2/"}},"next":null}}